diff -uNr linux-3.4.19.orig/drivers/net/ethernet/cadence/Kconfig linux-3.4.19/drivers/net/ethernet/cadence/Kconfig
--- linux-3.4.19.orig/drivers/net/ethernet/cadence/Kconfig	2012-11-17 13:16:56.000000000 -0800
+++ linux-3.4.19/drivers/net/ethernet/cadence/Kconfig	2013-03-05 10:45:55.467272941 -0800
@@ -45,4 +45,11 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called macb.
 
+config MACB_TX_SRAM
+    bool "Atmel MACB TX buffers in internal SRAM"
+    depends on NET_ETHERNET && MACB && (ARCH_AT91SAM9260 || ARCH_AT91SAM9263)
+    ---help---
+      Use internal SRAM for TX buffers.
+
+
 endif # NET_CADENCE
diff -uNr linux-3.4.19.orig/drivers/net/ethernet/cadence/macb.c linux-3.4.19/drivers/net/ethernet/cadence/macb.c
--- linux-3.4.19.orig/drivers/net/ethernet/cadence/macb.c	2012-11-17 13:16:56.000000000 -0800
+++ linux-3.4.19/drivers/net/ethernet/cadence/macb.c	2013-03-05 10:43:23.679277576 -0800
@@ -29,6 +29,12 @@
 
 #include "macb.h"
 
+#if defined(CONFIG_ARCH_AT91) && defined(CONFIG_MACB_TX_SRAM)
+#if defined(CONFIG_ARCH_AT91SAM9260)
+#include <mach/at91sam9260_matrix.h>
+#endif
+#endif
+
 #define RX_BUFFER_SIZE		128
 #define RX_RING_SIZE		512
 #define RX_RING_BYTES		(sizeof(struct dma_desc) * RX_RING_SIZE)
@@ -36,9 +42,21 @@
 /* Make the IP header word-aligned (the ethernet header is 14 bytes) */
 #define RX_OFFSET		2
 
-#define TX_RING_SIZE		128
+#if defined(CONFIG_ARCH_AT91) && defined(CONFIG_MACB_TX_SRAM)
+       #if defined(CONFIG_ARCH_AT91SAM9260)
+               #define TX_RING_SIZE       2
+       #elif defined(CONFIG_ARCH_AT91SAM9263)
+               #define TX_RING_SIZE       32
+       #endif
+       #define TX_BUFFER_SIZE       1536
+       #define TX_RING_BYTES        (sizeof(struct dma_desc) * TX_RING_SIZE)
+       #define TX_DMA_SIZE      ((TX_RING_BYTES) + (TX_RING_SIZE) * (TX_BUFFER_SIZE))
+#else
+       #define TX_RING_SIZE     128
+       #define TX_RING_BYTES        (sizeof(struct dma_desc) * TX_RING_SIZE)
+#endif
+
 #define DEF_TX_RING_PENDING	(TX_RING_SIZE - 1)
-#define TX_RING_BYTES		(sizeof(struct dma_desc) * TX_RING_SIZE)
 
 #define TX_RING_GAP(bp)						\
 	(TX_RING_SIZE - (bp)->tx_pending)
@@ -370,8 +388,10 @@
 
 		netdev_dbg(bp->dev, "skb %u (data %p) TX complete\n",
 			   tail, skb->data);
+#if !defined(CONFIG_MACB_TX_SRAM)
 		dma_unmap_single(&bp->pdev->dev, rp->mapping, skb->len,
 				 DMA_TO_DEVICE);
+#endif
 		bp->stats.tx_packets++;
 		bp->stats.tx_bytes += skb->len;
 		rp->skb = NULL;
@@ -650,8 +670,13 @@
 
 	entry = bp->tx_head;
 	netdev_dbg(bp->dev, "Allocated ring entry %u\n", entry);
+#if defined(CONFIG_ARCH_AT91) && defined(CONFIG_MACB_TX_SRAM)
+       mapping = bp->tx_ring[entry].addr;
+       memcpy(bp->tx_buffers + entry * TX_BUFFER_SIZE, skb->data, len);
+#else
 	mapping = dma_map_single(&bp->pdev->dev, skb->data,
 				 len, DMA_TO_DEVICE);
+#endif
 	bp->tx_skb[entry].skb = skb;
 	bp->tx_skb[entry].mapping = mapping;
 	netdev_dbg(bp->dev, "Mapped skb data %p to DMA addr %08lx\n",
@@ -662,7 +687,9 @@
 	if (entry == (TX_RING_SIZE - 1))
 		ctrl |= MACB_BIT(TX_WRAP);
 
+#if !defined(CONFIG_MACB_TX_SRAM)
 	bp->tx_ring[entry].addr = mapping;
+#endif
 	bp->tx_ring[entry].ctrl = ctrl;
 	wmb();
 
@@ -693,8 +720,12 @@
 		bp->rx_ring = NULL;
 	}
 	if (bp->tx_ring) {
+#if defined(CONFIG_ARCH_AT91) && defined(CONFIG_MACB_TX_SRAM)
+               iounmap((void *)bp->tx_ring);
+#else
 		dma_free_coherent(&bp->pdev->dev, TX_RING_BYTES,
 				  bp->tx_ring, bp->tx_ring_dma);
+#endif
 		bp->tx_ring = NULL;
 	}
 	if (bp->rx_buffers) {
@@ -703,6 +734,11 @@
 				  bp->rx_buffers, bp->rx_buffers_dma);
 		bp->rx_buffers = NULL;
 	}
+
+#if defined(CONFIG_ARCH_AT91) && defined(CONFIG_MACB_TX_SRAM)
+       if (bp->tx_ring_dma)
+               release_mem_region(bp->tx_ring_dma, TX_DMA_SIZE);
+#endif
 }
 
 static int macb_alloc_consistent(struct macb *bp)
@@ -722,7 +758,38 @@
 	netdev_dbg(bp->dev,
 		   "Allocated RX ring of %d bytes at %08lx (mapped %p)\n",
 		   size, (unsigned long)bp->rx_ring_dma, bp->rx_ring);
+#if defined(CONFIG_ARCH_AT91) && defined(CONFIG_MACB_TX_SRAM)
+#if  defined(CONFIG_ARCH_AT91SAM9260)
+       /* Work around for the TX underrun errata. Grant the EMAC master
+        * the highest priority access to EBI0 slave - SDRAMC */
+       at91_sys_write(AT91_MATRIX_SCFG4, 0x01000000);
+       at91_sys_write(AT91_MATRIX_PRAS4, 0x00030000);
+       if (request_mem_region(AT91SAM9260_SRAM0_BASE, TX_DMA_SIZE, "macb")) {
+               bp->tx_ring_dma = AT91SAM9260_SRAM0_BASE;
+       } else {
+               if (request_mem_region(AT91SAM9260_SRAM1_BASE, TX_DMA_SIZE, "macb")) {
+                       bp->tx_ring_dma = AT91SAM9260_SRAM1_BASE;
+               } else {
+                       printk(KERN_WARNING "Cannot request SRAM memory for TX ring, already used\n");
+                       return -EBUSY;
+               }
+       }
+#elif defined(CONFIG_ARCH_AT91SAM9263)
+       if (request_mem_region(AT91SAM9263_SRAM0_BASE, TX_DMA_SIZE, "macb")) {
+               bp->tx_ring_dma = AT91SAM9263_SRAM0_BASE;
+       } else {
+               printk(KERN_WARNING "Cannot request SRAM memory for TX ring, already used\n");
+               return -EBUSY;
+       }
+#endif
 
+       bp->tx_ring = ioremap(bp->tx_ring_dma, TX_DMA_SIZE);
+       if (!bp->tx_ring)
+               return -ENOMEM;
+
+       bp->tx_buffers_dma = bp->tx_ring_dma + TX_RING_BYTES;
+       bp->tx_buffers = (char *) bp->tx_ring + TX_RING_BYTES;
+#else
 	size = TX_RING_BYTES;
 	bp->tx_ring = dma_alloc_coherent(&bp->pdev->dev, size,
 					 &bp->tx_ring_dma, GFP_KERNEL);
@@ -740,7 +807,7 @@
 	netdev_dbg(bp->dev,
 		   "Allocated RX buffers of %d bytes at %08lx (mapped %p)\n",
 		   size, (unsigned long)bp->rx_buffers_dma, bp->rx_buffers);
-
+#endif
 	return 0;
 
 out_err:
@@ -761,10 +828,18 @@
 	}
 	bp->rx_ring[RX_RING_SIZE - 1].addr |= MACB_BIT(RX_WRAP);
 
+#if defined(CONFIG_ARCH_AT91) && defined(CONFIG_MACB_TX_SRAM)
+       for (i = 0; i < TX_RING_SIZE; i++) {
+               bp->tx_ring[i].addr = bp->tx_buffers_dma + i * TX_BUFFER_SIZE;
+               bp->tx_ring[i].ctrl = MACB_BIT(TX_USED);
+       }
+#else
 	for (i = 0; i < TX_RING_SIZE; i++) {
 		bp->tx_ring[i].addr = 0;
 		bp->tx_ring[i].ctrl = MACB_BIT(TX_USED);
 	}
+#endif
+
 	bp->tx_ring[TX_RING_SIZE - 1].ctrl |= MACB_BIT(TX_WRAP);
 
 	bp->rx_tail = bp->tx_head = bp->tx_tail = 0;
diff -uNr linux-3.4.19.orig/drivers/net/ethernet/cadence/macb.h linux-3.4.19/drivers/net/ethernet/cadence/macb.h
--- linux-3.4.19.orig/drivers/net/ethernet/cadence/macb.h	2012-11-17 13:16:56.000000000 -0800
+++ linux-3.4.19/drivers/net/ethernet/cadence/macb.h	2013-03-05 10:38:34.523286408 -0800
@@ -509,8 +509,13 @@
 	struct dma_desc		*tx_ring;
 	struct ring_info	*tx_skb;
 
+#if defined(CONFIG_ARCH_AT91)
+       void            *tx_buffers;
+#endif
+
 	spinlock_t		lock;
 	struct platform_device	*pdev;
+        struct clk      *macb_clk;
 	struct clk		*pclk;
 	struct clk		*hclk;
 	struct net_device	*dev;
@@ -525,6 +530,10 @@
 	dma_addr_t		tx_ring_dma;
 	dma_addr_t		rx_buffers_dma;
 
+#if defined(CONFIG_ARCH_AT91)
+       dma_addr_t      tx_buffers_dma;
+#endif
+
 	unsigned int		rx_pending, tx_pending;
 
 	struct mii_bus		*mii_bus;
