diff -uNr linux-3.4.19.orig/arch/arm/mach-at91/at91sam9260_devices.c linux-3.4.19/arch/arm/mach-at91/at91sam9260_devices.c
--- linux-3.4.19.orig/arch/arm/mach-at91/at91sam9260_devices.c	2012-11-17 13:16:56.000000000 -0800
+++ linux-3.4.19/arch/arm/mach-at91/at91sam9260_devices.c	2013-03-16 17:26:18.013114420 -0700
@@ -923,7 +923,7 @@
 
 static inline void configure_dbgu_pins(void)
 {
-	at91_set_A_periph(AT91_PIN_PB14, 0);		/* DRXD */
+	at91_set_A_periph(AT91_PIN_PB14, 1);		/* DRXD */
 	at91_set_A_periph(AT91_PIN_PB15, 1);		/* DTXD */
 }
 
@@ -1019,6 +1019,16 @@
 		at91_set_A_periph(AT91_PIN_PB28, 0);	/* RTS1 */
 	if (pins & ATMEL_UART_CTS)
 		at91_set_A_periph(AT91_PIN_PB29, 0);	/* CTS1 */
+	//P.S.  Only USART 0 has direct peripheral pins for modem control
+	//      so we use gpio on USART 1 and modify atmel_serial.c 
+	if (pins & ATMEL_UART_DTR)
+		at91_set_gpio_output(AT91_PIN_PB20, 0); /* DTR1 */
+	if (pins & ATMEL_UART_DSR)
+		at91_set_GPIO_periph(AT91_PIN_PB18, 1);	/* DSR1 */
+	if (pins & ATMEL_UART_DCD)
+		at91_set_GPIO_periph(AT91_PIN_PB19, 1);	/* DCD1 */
+	if (pins & ATMEL_UART_RI)
+		at91_set_GPIO_periph(AT91_PIN_PB21, 1);	/* RI1 */
 }
 
 static struct resource uart2_resources[] = {
diff -uNr linux-3.4.19.orig/arch/arm/mach-at91/board-sam9260ek.c linux-3.4.19/arch/arm/mach-at91/board-sam9260ek.c
--- linux-3.4.19.orig/arch/arm/mach-at91/board-sam9260ek.c	2012-11-17 13:16:56.000000000 -0800
+++ linux-3.4.19/arch/arm/mach-at91/board-sam9260ek.c	2013-03-16 17:31:39.577122654 -0700
@@ -63,8 +63,16 @@
 			   | ATMEL_UART_DTR | ATMEL_UART_DSR | ATMEL_UART_DCD
 			   | ATMEL_UART_RI);
 
-	/* USART1 on ttyS2. (Rx, Tx, RTS, CTS) */
-	at91_register_uart(AT91SAM9260_ID_US1, 2, ATMEL_UART_CTS | ATMEL_UART_RTS);
+	/* USART1 on ttyS2. (Rx, Tx, RTS, CTS, DTR, DSR, DCD, RI) */
+	at91_register_uart(AT91SAM9260_ID_US1, 2, ATMEL_UART_CTS | ATMEL_UART_RTS
+			   | ATMEL_UART_DTR | ATMEL_UART_DSR | ATMEL_UART_DCD
+			   | ATMEL_UART_RI);
+
+	/* USART2 RS-422/485 on ttyS3. (Rx, Tx ) */
+	at91_register_uart(AT91SAM9260_ID_US2, 3,0);
+
+	/* USART3 RS-422/485 on ttyS4 (Rx, Tx ) */
+	at91_register_uart(AT91SAM9260_ID_US3, 4,0);
 
 	/* set serial console to ttyS0 (ie, DBGU) */
 	at91_set_serial_console(0);
@@ -87,36 +95,6 @@
 	.pullup_pin	= -EINVAL,		/* pull-up driven by UDC */
 };
 
-
-/*
- * Audio
- */
-static struct at73c213_board_info at73c213_data = {
-	.ssc_id		= 0,
-	.shortname	= "AT91SAM9260-EK external DAC",
-};
-
-#if defined(CONFIG_SND_AT73C213) || defined(CONFIG_SND_AT73C213_MODULE)
-static void __init at73c213_set_clk(struct at73c213_board_info *info)
-{
-	struct clk *pck0;
-	struct clk *plla;
-
-	pck0 = clk_get(NULL, "pck0");
-	plla = clk_get(NULL, "plla");
-
-	/* AT73C213 MCK Clock */
-	at91_set_B_periph(AT91_PIN_PC1, 0);	/* PCK0 */
-
-	clk_set_parent(pck0, plla);
-	clk_put(plla);
-
-	info->dac_clk = pck0;
-}
-#else
-static void __init at73c213_set_clk(struct at73c213_board_info *info) {}
-#endif
-
 /*
  * SPI devices.
  */
@@ -137,16 +115,6 @@
 	},
 #endif
 #endif
-#if defined(CONFIG_SND_AT73C213) || defined(CONFIG_SND_AT73C213_MODULE)
-	{	/* AT73C213 DAC */
-		.modalias	= "at73c213",
-		.chip_select	= 0,
-		.max_speed_hz	= 10 * 1000 * 1000,
-		.bus_num	= 1,
-		.mode		= SPI_MODE_1,
-		.platform_data	= &at73c213_data,
-	},
-#endif
 };
 
 
@@ -164,9 +132,14 @@
  */
 static struct mtd_partition __initdata ek_nand_partition[] = {
 	{
+		.name   = "Bootstrap",
+		.offset = 0,
+		.size   = 4 * SZ_1M,
+	},
+	{
 		.name	= "Partition 1",
-		.offset	= 0,
-		.size	= SZ_256K,
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 60 * SZ_1M,
 	},
 	{
 		.name	= "Partition 2",
@@ -237,85 +210,49 @@
  * LEDs
  */
 static struct gpio_led ek_leds[] = {
-	{	/* "bottom" led, green, userled1 to be defined */
-		.name			= "ds5",
-		.gpio			= AT91_PIN_PA6,
-		.active_low		= 1,
+	{	/* "left" led, red */
+		.name			= "d4-red",
+		.gpio			= AT91_PIN_PC6,
+		.active_low		= 0,
 		.default_trigger	= "none",
 	},
-	{	/* "power" led, yellow */
-		.name			= "ds1",
-		.gpio			= AT91_PIN_PA9,
-		.default_trigger	= "heartbeat",
-	}
-};
-
-/*
- * I2C devices
- */
-static struct at24_platform_data at24c512 = {
-	.byte_len	= SZ_512K / 8,
-	.page_size	= 128,
-	.flags		= AT24_FLAG_ADDR16,
-};
-
-static struct i2c_board_info __initdata ek_i2c_devices[] = {
-	{
-		I2C_BOARD_INFO("24c512", 0x50),
-		.platform_data = &at24c512,
+	{	/* "left" led, green */
+		.name			= "d4-green",
+		.gpio			= AT91_PIN_PC7,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* "right" led, green */
+		.name			= "d5-green",
+		.gpio			= AT91_PIN_PC8,
+		.active_low		= 0,
+		.default_trigger	= "none",
 	},
-	/* more devices can be added using expansion connectors */
+	{	/* "right" led, yellow */
+		.name			= "d5-yellow",
+		.gpio			= AT91_PIN_PC10,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	}
 };
 
 
 /*
- * GPIO Buttons
+ * GPIO Switches
  */
-#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
-static struct gpio_keys_button ek_buttons[] = {
-	{
-		.gpio		= AT91_PIN_PA30,
-		.code		= BTN_3,
-		.desc		= "Button 3",
-		.active_low	= 1,
-		.wakeup		= 1,
-	},
-	{
-		.gpio		= AT91_PIN_PA31,
-		.code		= BTN_4,
-		.desc		= "Button 4",
-		.active_low	= 1,
-		.wakeup		= 1,
-	}
-};
-
-static struct gpio_keys_platform_data ek_button_data = {
-	.buttons	= ek_buttons,
-	.nbuttons	= ARRAY_SIZE(ek_buttons),
-};
+static struct gpio_keys_button ek_keys[] = {
 
-static struct platform_device ek_button_device = {
-	.name		= "gpio-keys",
-	.id		= -1,
-	.num_resources	= 0,
-	.dev		= {
-		.platform_data	= &ek_button_data,
+	{	/* " SW1 -  user defined switch */
+		.code			= EV_KEY,
+		.gpio			= AT91_PIN_PC4,
+		.active_low		= 1,
+		.desc			= "sw1",
+		.type			= EV_KEY,
+		.wakeup			= 0,
+		.debounce_interval	= 100,		
 	}
 };
 
-static void __init ek_add_device_buttons(void)
-{
-	at91_set_gpio_input(AT91_PIN_PA30, 1);	/* btn3 */
-	at91_set_deglitch(AT91_PIN_PA30, 1);
-	at91_set_gpio_input(AT91_PIN_PA31, 1);	/* btn4 */
-	at91_set_deglitch(AT91_PIN_PA31, 1);
-
-	platform_device_register(&ek_button_device);
-}
-#else
-static void __init ek_add_device_buttons(void) {}
-#endif
-
 
 static void __init ek_board_init(void)
 {
@@ -333,15 +270,10 @@
 	at91_add_device_eth(&ek_macb_data);
 	/* MMC */
 	at91_add_device_mmc(0, &ek_mmc_data);
-	/* I2C */
-	at91_add_device_i2c(ek_i2c_devices, ARRAY_SIZE(ek_i2c_devices));
-	/* SSC (to AT73C213) */
-	at73c213_set_clk(&at73c213_data);
-	at91_add_device_ssc(AT91SAM9260_ID_SSC, ATMEL_SSC_TX);
 	/* LEDs */
 	at91_gpio_leds(ek_leds, ARRAY_SIZE(ek_leds));
-	/* Push Buttons */
-	ek_add_device_buttons();
+	/* Switches */
+	at91_gpio_keys(ek_keys, ARRAY_SIZE(ek_keys));
 }
 
 MACHINE_START(AT91SAM9260EK, "Atmel AT91SAM9260-EK")
diff -uNr linux-3.4.19.orig/arch/arm/mach-at91/include/mach/board.h linux-3.4.19/arch/arm/mach-at91/include/mach/board.h
--- linux-3.4.19.orig/arch/arm/mach-at91/include/mach/board.h	2012-11-17 13:16:56.000000000 -0800
+++ linux-3.4.19/arch/arm/mach-at91/include/mach/board.h	2013-03-16 17:26:31.617114768 -0700
@@ -35,6 +35,8 @@
 #include <linux/device.h>
 #include <linux/i2c.h>
 #include <linux/leds.h>
+#include <linux/input.h>
+#include <linux/gpio_keys.h>
 #include <linux/spi/spi.h>
 #include <linux/usb/atmel_usba_udc.h>
 #include <linux/atmel-mci.h>
@@ -192,6 +194,9 @@
 extern void __init at91_gpio_leds(struct gpio_led *leds, int nr);
 extern void __init at91_pwm_leds(struct gpio_led *leds, int nr);
 
+ /* Switches */
+extern void __init at91_gpio_keys(struct gpio_keys_button *keys, int nr);
+
 /* FIXME: this needs a better location, but gets stuff building again */
 extern int at91_suspend_entering_slow_clock(void);
 
diff -uNr linux-3.4.19.orig/arch/arm/mach-at91/Makefile linux-3.4.19/arch/arm/mach-at91/Makefile
--- linux-3.4.19.orig/arch/arm/mach-at91/Makefile	2012-11-17 13:16:56.000000000 -0800
+++ linux-3.4.19/arch/arm/mach-at91/Makefile	2013-03-16 17:26:31.617114768 -0700
@@ -85,7 +85,7 @@
 obj-$(CONFIG_MACH_AT91EB01)	+= board-eb01.o
 
 # Drivers
-obj-y				+= leds.o
+obj-y				+= leds.o switches.o
 
 # Power Management
 obj-$(CONFIG_PM)		+= pm.o
diff -uNr linux-3.4.19.orig/arch/arm/mach-at91/switches.c linux-3.4.19/arch/arm/mach-at91/switches.c
--- linux-3.4.19.orig/arch/arm/mach-at91/switches.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-3.4.19/arch/arm/mach-at91/switches.c	2013-03-16 17:26:31.617114768 -0700
@@ -0,0 +1,50 @@
+/*
+ * Switch driver for Atmel AT91-based boards.
+ *
+ *  Copyright (C) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+#include <mach/board.h>
+#include <mach/gpio.h>
+
+
+/* ------------------------------------------------------------------------- */
+
+
+/*
+ * New cross-platform  Switch support.
+ */
+
+static struct gpio_keys_platform_data keys_data;
+
+static struct platform_device at91_gpio_keys_device = {
+	.name			= "gpio-keys",
+	.id			= -1,
+	.dev.platform_data	= &keys_data,
+};
+
+void __init at91_gpio_keys(struct gpio_keys_button *keys, int nr)
+{
+	int i;
+
+	if (!nr)
+		return;
+
+	for (i = 0; i < nr; i++)
+          at91_set_GPIO_periph(keys[i].gpio, keys[i].active_low);
+
+	keys_data.buttons = keys;
+	keys_data.nbuttons = nr;
+	platform_device_register(&at91_gpio_keys_device);
+}
+
diff -uNr linux-3.4.19.orig/drivers/tty/serial/atmel_serial.c linux-3.4.19/drivers/tty/serial/atmel_serial.c
--- linux-3.4.19.orig/drivers/tty/serial/atmel_serial.c	2012-11-17 13:16:56.000000000 -0800
+++ linux-3.4.19/drivers/tty/serial/atmel_serial.c	2013-03-16 17:26:31.617114768 -0700
@@ -286,13 +286,24 @@
 	else
 		control |= ATMEL_US_RTSDIS;
 
-	if (mctrl & TIOCM_DTR)
-		control |= ATMEL_US_DTREN;
-	else
-		control |= ATMEL_US_DTRDIS;
-
-	UART_PUT_CR(port, control);
-
+	//P.S. Handle control signals on ttyS2 of Ctek CK801 board. Atmel does not
+	//     map these through peripheral pins so we use gpio
+        if(port->line == 2)
+        {
+	 	if (mctrl & TIOCM_DTR)
+			at91_set_gpio_value(AT91_PIN_PB20, 0);
+		else
+			at91_set_gpio_value(AT91_PIN_PB20, 1);
+        }
+        else
+        {
+	 	if (mctrl & TIOCM_DTR)
+	 		control |= ATMEL_US_DTREN;
+		else
+			control |= ATMEL_US_DTRDIS;
+        }
+        UART_PUT_CR(port, control);	
+	
 	/* Local loopback mode? */
 	mode = UART_GET_MR(port) & ~ATMEL_US_CHMODE;
 	if (mctrl & TIOCM_LOOP)
@@ -322,23 +333,39 @@
 {
 	unsigned int status, ret = 0;
 
-	status = UART_GET_CSR(port);
-
-	/*
-	 * The control signals are active low.
-	 */
-	if (!(status & ATMEL_US_DCD))
-		ret |= TIOCM_CD;
-	if (!(status & ATMEL_US_CTS))
-		ret |= TIOCM_CTS;
-	if (!(status & ATMEL_US_DSR))
-		ret |= TIOCM_DSR;
-	if (!(status & ATMEL_US_RI))
-		ret |= TIOCM_RI;
+    	status = UART_GET_CSR(port);
 
+//P.S. Handle control signals on ttyS2 of Ctek CK801 board. Atmel does not
+//     map these through peripheral pins so we use gpio
+        if(port->line == 2)
+        {
+         	if(!(at91_get_gpio_value(AT91_PIN_PB19)))
+			ret |= TIOCM_CD;
+         	if(!(at91_get_gpio_value(AT91_PIN_PB18)))
+			ret |= TIOCM_DSR;
+         	if(!(at91_get_gpio_value(AT91_PIN_PB21)))
+			ret |= TIOCM_RI;
+	    	if (!(status & ATMEL_US_CTS))
+	    		ret |= TIOCM_CTS;
+        }
+	else
+	{
+	    	/*
+	    	 * The control signals are active low.
+ 	   	 */
+	    	if (!(status & ATMEL_US_DCD))
+ 	   		ret |= TIOCM_CD;
+	    	if (!(status & ATMEL_US_CTS))
+	    		ret |= TIOCM_CTS;
+	    	if (!(status & ATMEL_US_DSR))
+	    		ret |= TIOCM_DSR;
+	    	if (!(status & ATMEL_US_RI))
+ 	   		ret |= TIOCM_RI;
+        }
 	return ret;
 }
 
+
 /*
  * Stop transmitting.
  */
